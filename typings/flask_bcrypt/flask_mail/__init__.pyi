"""
This type stub file was generated by pyright.
"""

import collections.abc as c
import re
import smtplib
import time
import typing as t
import unicodedata
import warnings
import blinker
import typing_extensions as te
from contextlib import contextmanager
from email import charset, policy
from email.encoders import encode_base64
from email.header import Header
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import formataddr, formatdate, make_msgid, parseaddr
from mimetypes import guess_type
from types import TracebackType
from flask import Flask, current_app

if t.TYPE_CHECKING:
    ...
class FlaskMailUnicodeDecodeError(UnicodeDecodeError):
    def __init__(self, obj: t.Any, *args: t.Any) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def force_text(s: t.Any, encoding: str = ..., errors: str = ...) -> str:
    """
    Similar to smart_text, except that lazy instances are resolved to
    strings, rather than kept as lazy objects.
    """
    ...

def sanitize_subject(subject: str, encoding: str = ...) -> str:
    ...

def sanitize_address(addr: str | tuple[str, str], encoding: str = ...) -> str:
    ...

def sanitize_addresses(addresses: c.Iterable[str | tuple[str, str]], encoding: str = ...) -> list[str]:
    ...

class Connection:
    """Handles connection to host."""
    def __init__(self, mail: Mail) -> None:
        ...
    
    def __enter__(self) -> te.Self:
        ...
    
    def __exit__(self, exc_type: type[BaseException], exc_value: BaseException, tb: TracebackType) -> None:
        ...
    
    def configure_host(self) -> smtplib.SMTP | smtplib.SMTP_SSL:
        ...
    
    def send(self, message: Message, envelope_from: str | tuple[str, str] | None = ...) -> None:
        """Verifies and sends message.

        :param message: Message instance.
        :param envelope_from: Email address to be used in MAIL FROM command.
        """
        ...
    
    def send_message(self, *args: t.Any, **kwargs: t.Any) -> None:
        """Shortcut for send(msg).

        Takes same arguments as Message constructor.

        :versionadded: 0.3.5
        """
        ...
    


class BadHeaderError(Exception):
    ...


class Attachment:
    """Encapsulates file attachment information.

    :param filename: filename of attachment
    :param content_type: file mimetype
    :param data: the raw file data
    :param disposition: content-disposition (if any)

    .. versionchanged:: 0.10.0
        The `data` argument is required.

    .. versionadded: 0.3.5
    """
    def __init__(self, filename: str | None = ..., content_type: str | None = ..., data: str | bytes | None = ..., disposition: str | None = ..., headers: dict[str, str] | None = ...) -> None:
        ...
    


class Message:
    """Encapsulates an email message.

    :param subject: email subject header
    :param recipients: list of email addresses
    :param body: plain text message
    :param html: HTML message
    :param alts: A dict or an iterable to go through dict() that contains multipart
                 alternatives
    :param sender: email sender address, or **MAIL_DEFAULT_SENDER** by default
    :param cc: CC list
    :param bcc: BCC list
    :param attachments: list of Attachment instances
    :param reply_to: reply-to address
    :param date: send date
    :param charset: message character set
    :param extra_headers: A dictionary of additional headers for the message
    :param mail_options: A list of ESMTP options to be used in MAIL FROM command
    :param rcpt_options:  A list of ESMTP options to be used in RCPT commands
    """
    def __init__(self, subject: str = ..., recipients: list[str | tuple[str, str]] | None = ..., body: str | None = ..., html: str | None = ..., alts: dict[str, str] | c.Iterable[tuple[str, str]] | None = ..., sender: str | tuple[str, str] | None = ..., cc: list[str | tuple[str, str]] | None = ..., bcc: list[str | tuple[str, str]] | None = ..., attachments: list[Attachment] | None = ..., reply_to: str | tuple[str, str] | None = ..., date: float | None = ..., charset: str | None = ..., extra_headers: dict[str, str] | None = ..., mail_options: list[str] | None = ..., rcpt_options: list[str] | None = ...) -> None:
        ...
    
    @property
    def send_to(self) -> set[str | tuple[str, str]]:
        ...
    
    @property
    def html(self) -> str | None:
        ...
    
    @html.setter
    def html(self, value: str | None) -> None:
        ...
    
    def as_string(self) -> str:
        ...
    
    def as_bytes(self) -> bytes:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __bytes__(self) -> bytes:
        ...
    
    def has_bad_headers(self) -> bool:
        """Checks for bad headers i.e. newlines in subject, sender or recipients.
        RFC5322: Allows multiline CRLF with trailing whitespace (FWS) in headers
        """
        ...
    
    def is_bad_headers(self) -> bool:
        ...
    
    def send(self, connection: Connection) -> None:
        """Verifies and sends the message."""
        ...
    
    def add_recipient(self, recipient: str | tuple[str, str]) -> None:
        """Adds another recipient to the message.

        :param recipient: email address of recipient.
        """
        ...
    
    def attach(self, filename: str | None = ..., content_type: str | None = ..., data: str | bytes | None = ..., disposition: str | None = ..., headers: dict[str, str] | None = ...) -> None:
        """Adds an attachment to the message.

        :param filename: filename of attachment
        :param content_type: file mimetype
        :param data: the raw file data
        :param disposition: content-disposition (if any)
        """
        ...
    


class _MailMixin:
    @contextmanager
    def record_messages(self) -> c.Iterator[list[Message]]:
        """Records all messages. Use in unit tests for example::

            with mail.record_messages() as outbox:
                response = app.test_client.get("/email-sending-view/")
                assert len(outbox) == 1
                assert outbox[0].subject == "testing"

        :versionadded: 0.4
        """
        ...
    
    def send(self, message: Message) -> None:
        """Sends a single message instance. If TESTING is True the message will
        not actually be sent.

        :param message: a Message instance.
        """
        ...
    
    def send_message(self, *args: t.Any, **kwargs: t.Any) -> None:
        """Shortcut for send(msg).

        Takes same arguments as Message constructor.

        :versionadded: 0.3.5
        """
        ...
    
    def connect(self) -> Connection:
        """Opens a connection to the mail host."""
        ...
    


class _Mail(_MailMixin):
    def __init__(self, server: str, username: str | None, password: str | None, port: int | None, use_tls: bool, use_ssl: bool, default_sender: str | None, debug: int, max_emails: int | None, suppress: bool, ascii_attachments: bool) -> None:
        ...
    


class Mail(_MailMixin):
    """Manages email messaging."""
    def __init__(self, app: Flask | None = ...) -> None:
        ...
    
    def init_mail(self, config: dict[str, t.Any], debug: bool | int = ..., testing: bool = ...) -> _Mail:
        ...
    
    def init_app(self, app: Flask) -> _Mail:
        """Initializes your mail settings from the application settings.

        You can use this if you want to set up your Mail instance
        at configuration time.
        """
        ...
    
    def __getattr__(self, name: str) -> t.Any:
        ...
    


signals: blinker.Namespace = ...
email_dispatched: blinker.NamedSignal = ...
def __getattr__(name: str) -> t.Any:
    ...

