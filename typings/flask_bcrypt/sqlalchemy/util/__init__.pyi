"""
This type stub file was generated by pyright.
"""

import asyncio
import sys
import typing
from contextvars import Context
from typing import Any, Awaitable, Callable, Coroutine, Optional, TYPE_CHECKING, TypeVar, Union
from .langhelpers import memoized_property
from .. import exc
from ..util import py311
from ..util.typing import Literal, Protocol, Self, TypeGuard

_T = TypeVar("_T")
if typing.TYPE_CHECKING:
    class greenlet(Protocol):
        dead: bool
        gr_context: Optional[Context]
        def __init__(self, fn: Callable[..., Any], driver: greenlet) -> None:
            ...
        
        def throw(self, *arg: Any) -> Any:
            ...
        
        def switch(self, value: Any) -> Any:
            ...
        
    
    
    def getcurrent() -> greenlet:
        ...
    
else:
    ...
_has_gr_context = ...
def is_exit_exception(e: BaseException) -> bool:
    ...

class _AsyncIoGreenlet(greenlet):
    dead: bool
    __sqlalchemy_greenlet_provider__ = ...
    def __init__(self, fn: Callable[..., Any], driver: greenlet) -> None:
        ...
    


_T_co = TypeVar("_T_co", covariant=True)
if TYPE_CHECKING:
    def iscoroutine(awaitable: Awaitable[_T_co]) -> TypeGuard[Coroutine[Any, Any, _T_co]]:
        ...
    
else:
    ...
def in_greenlet() -> bool:
    ...

def await_only(awaitable: Awaitable[_T]) -> _T:
    """Awaits an async function in a sync method.

    The sync method must be inside a :func:`greenlet_spawn` context.
    :func:`await_only` calls cannot be nested.

    :param awaitable: The coroutine to call.

    """
    ...

def await_fallback(awaitable: Awaitable[_T]) -> _T:
    """Awaits an async function in a sync method.

    The sync method must be inside a :func:`greenlet_spawn` context.
    :func:`await_fallback` calls cannot be nested.

    :param awaitable: The coroutine to call.

    .. deprecated:: 2.0.24 The ``await_fallback()`` function will be removed
       in SQLAlchemy 2.1.  Use :func:`_util.await_only` instead, running the
       function / program / etc. within a top-level greenlet that is set up
       using :func:`_util.greenlet_spawn`.

    """
    ...

async def greenlet_spawn(fn: Callable[..., _T], *args: Any, _require_await: bool = ..., **kwargs: Any) -> _T:
    """Runs a sync function ``fn`` in a new greenlet.

    The sync function can then use :func:`await_only` to wait for async
    functions.

    :param fn: The sync callable to call.
    :param \\*args: Positional arguments to pass to the ``fn`` callable.
    :param \\*\\*kwargs: Keyword arguments to pass to the ``fn`` callable.
    """
    ...

class AsyncAdaptedLock:
    @memoized_property
    def mutex(self) -> asyncio.Lock:
        ...
    
    def __enter__(self) -> bool:
        ...
    
    def __exit__(self, *arg: Any, **kw: Any) -> None:
        ...
    


def get_event_loop() -> asyncio.AbstractEventLoop:
    """vendor asyncio.get_event_loop() for python 3.7 and above.

    Python 3.10 deprecates get_event_loop() as a standalone.

    """
    ...

if not TYPE_CHECKING and py311:
    ...
else:
    class _Runner:
        """Runner implementation for test only"""
        _loop: Union[None, asyncio.AbstractEventLoop, Literal[False]]
        def __init__(self) -> None:
            ...
        
        def __enter__(self) -> Self:
            ...
        
        def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
            ...
        
        def close(self) -> None:
            ...
        
        def get_loop(self) -> asyncio.AbstractEventLoop:
            """Return embedded event loop."""
            ...
        
        def run(self, coro: Coroutine[Any, Any, _T]) -> _T:
            ...
        
    
    
